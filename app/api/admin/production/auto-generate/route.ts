import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth/next'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session || session.user.role !== 'ADMIN') {
      return NextResponse.json({ error: 'Acceso denegado' }, { status: 403 })
    }

    const body = await request.json()
    const { 
      minStockMultiplier = 2, // Producir hasta tener 2x el stock mínimo
      priorityBoost = 2, // Aumentar prioridad para productos críticos
      autoAssignPrinter = true 
    } = body

    // Encontrar productos con stock bajo que necesitan producción
    const lowStockProducts = await prisma.product.findMany({
      where: {
        AND: [
          { isActive: true },
          {
            stock: {
              lte: prisma.product.fields.minStock
            }
          }
        ]
      },
      include: {
        category: {
          select: { name: true }
        }
      },
      orderBy: {
        stock: 'asc' // Los más críticos primero
      }
    })

    if (lowStockProducts.length === 0) {
      return NextResponse.json({ 
        message: 'No hay productos con stock bajo que requieran producción',
        jobsCreated: []
      })
    }

    // Obtener el contador actual de trabajos para generar números únicos
    const jobCount = await prisma.productionJob.count()
    
    const createdJobs = []

    for (let i = 0; i < lowStockProducts.length; i++) {
      const product = lowStockProducts[i]
      
      // Verificar si ya existe un trabajo pendiente para este producto
      const existingJob = await prisma.productionJob.findFirst({
        where: {
          productId: product.id,
          status: {
            in: ['QUEUED', 'IN_PROGRESS', 'PAUSED']
          }
        }
      })

      if (existingJob) {
        console.log(`Ya existe trabajo pendiente para ${product.name}, saltando...`)
        continue
      }

      // Calcular cuántas unidades producir
      const targetStock = product.minStock * minStockMultiplier
      const quantityToProduce = Math.max(1, targetStock - product.stock)

      // Determinar prioridad basada en qué tan crítico está el stock
      let priority = 5 // Prioridad media por defecto
      if (product.stock === 0) {
        priority = 9 // Crítico
      } else if (product.stock <= product.minStock * 0.5) {
        priority = 7 // Alto
      } else if (product.stock <= product.minStock) {
        priority = 6 // Medio-Alto
      }

      // Aplicar boost de prioridad si se especifica
      priority = Math.min(10, priority + priorityBoost)

      // Estimar tiempo de producción (básico, puede mejorarse con datos históricos)
      const estimatedHoursPerUnit = 2 // 2 horas por unidad (ajustar según producto)
      const totalEstimatedHours = quantityToProduce * estimatedHoursPerUnit

      // Asignación automática de impresora (simplificada)
      let assignedPrinter = null
      if (autoAssignPrinter) {
        // Lógica simple: rotar entre impresoras disponibles
        const printers = ['Printer_001', 'Printer_002', 'Printer_003'] // Configurar según tu setup
        assignedPrinter = printers[i % printers.length]
      }

      // Generar número de trabajo único
      const jobNumber = `AUTO-${String(jobCount + i + 1).padStart(6, '0')}`

      // Crear trabajo de producción
      const job = await prisma.productionJob.create({
        data: {
          jobNumber,
          name: `Reposición: ${product.name}`,
          description: `Producción automática para reponer stock. Cantidad objetivo: ${quantityToProduce} unidades`,
          productId: product.id,
          status: 'QUEUED',
          priority,
          estimatedHours: totalEstimatedHours,
          printer: assignedPrinter,
          material: product.material || 'PLA', // Default material
          settings: {
            autoGenerated: true,
            targetQuantity: quantityToProduce,
            currentStock: product.stock,
            minStock: product.minStock,
            reason: 'Low stock replenishment'
          },
          files: [], // Se pueden agregar archivos STL por defecto del producto
          notes: `Trabajo generado automáticamente. Stock actual: ${product.stock}, Stock mínimo: ${product.minStock}`
        },
        include: {
          product: {
            select: {
              id: true,
              name: true,
              sku: true
            }
          }
        }
      })

      createdJobs.push({
        ...job,
        estimatedHours: job.estimatedHours ? parseFloat(job.estimatedHours.toString()) : null,
        actualHours: job.actualHours ? parseFloat(job.actualHours.toString()) : null
      })
    }

    return NextResponse.json({
      message: `Se crearon ${createdJobs.length} trabajos de producción automáticamente`,
      productsAnalyzed: lowStockProducts.length,
      jobsCreated: createdJobs,
      summary: {
        critical: createdJobs.filter(j => j.priority >= 9).length,
        high: createdJobs.filter(j => j.priority >= 7 && j.priority < 9).length,
        medium: createdJobs.filter(j => j.priority >= 5 && j.priority < 7).length,
        totalEstimatedHours: createdJobs.reduce((sum, j) => sum + (j.estimatedHours || 0), 0)
      }
    })

  } catch (error) {
    console.error('Auto-generate production jobs error:', error)
    return NextResponse.json(
      { error: 'Error al generar trabajos de producción automáticamente' },
      { status: 500 }
    )
  }
}